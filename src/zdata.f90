MODULE ZDATA

  USE :: ZMQ
  IMPLICIT NONE

  TYPE :: ZDATA_T
    PRIVATE
      TYPE(ZMQ_MSG_T) :: MESSAGE_
      INTEGER(KIND = C_SIZE_T) :: OFFSET_
      INTEGER(KIND = C_SIZE_T) :: SIZE_
      INTEGER(KIND = C_INT) :: STATE_
    CONTAINS
      PROCEDURE :: MSG => ZDATA_MSG
      PROCEDURE :: SIZE => ZDATA_SIZE
      PROCEDURE :: TELLP => ZDATA_TELLP

      PROCEDURE :: CLOSE => ZDATA_CLOSE
      PROCEDURE :: RECV => ZDATA_RECV
      PROCEDURE :: SEND => ZDATA_SEND
      PROCEDURE :: SWITCH_MODE => ZDATA_SWITCH_MODE

      PROCEDURE :: GET_BOOL => ZDATA_GET_BOOL
      PROCEDURE :: PUT_BOOL => ZDATA_PUT_BOOL

      PROCEDURE :: GET_INT => ZDATA_GET_INT
      PROCEDURE :: PUT_INT => ZDATA_PUT_INT
      PROCEDURE :: GET_LONG => ZDATA_GET_LONG
      PROCEDURE :: PUT_LONG => ZDATA_PUT_LONG
      PROCEDURE :: GET_SHORT => ZDATA_GET_SHORT
      PROCEDURE :: PUT_SHORT => ZDATA_PUT_SHORT

      PROCEDURE :: GET_FLOAT => ZDATA_GET_FLOAT
      PROCEDURE :: PUT_FLOAT => ZDATA_PUT_FLOAT
      PROCEDURE :: GET_DOUBLE => ZDATA_GET_DOUBLE
      PROCEDURE :: PUT_DOUBLE => ZDATA_PUT_DOUBLE

      PROCEDURE :: GET_CHAR => ZDATA_GET_CHAR
      PROCEDURE :: PUT_CHAR => ZDATA_PUT_CHAR
      PROCEDURE :: GET_C_STRING => ZDATA_GET_C_STRING
      PROCEDURE :: PUT_C_STRING => ZDATA_PUT_C_STRING
      PROCEDURE :: GET_STRING => ZDATA_GET_STRING
      PROCEDURE :: PUT_STRING => ZDATA_PUT_STRING

      PROCEDURE :: BAD => ZDATA_BAD
      PROCEDURE :: EOM => ZDATA_EOM
      PROCEDURE :: FAIL => ZDATA_FAIL
      PROCEDURE :: GOOD => ZDATA_GOOD
      PROCEDURE :: CLEAR_FAIL => ZDATA_CLEAR_FAIL
  END TYPE ZDATA_T

  ! STATE FLAGS
  INTEGER, PARAMETER :: ZDATA_RECVBIT = 1
  INTEGER, PARAMETER :: ZDATA_SENDBIT = 2
  INTEGER, PARAMETER :: ZDATA_EOMBIT  = 3
  INTEGER, PARAMETER :: ZDATA_FAILBIT = 4
  INTEGER, PARAMETER :: ZDATA_BADBIT  = 5

  INTERFACE ZDATA_T

    MODULE PROCEDURE ZDATA_INIT
    MODULE PROCEDURE ZDATA_INIT_INT
    MODULE PROCEDURE ZDATA_INIT_SIZE

  END INTERFACE ZDATA_T

CONTAINS

  FUNCTION ZDATA_BAD(ZDATA) RESULT(FLAG)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(IN) :: ZDATA
    LOGICAL :: FLAG

    FLAG = BTEST(ZDATA%STATE_, ZDATA_BADBIT)

  END FUNCTION ZDATA_BAD

  SUBROUTINE ZDATA_CLEAR_FAIL(ZDATA)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA

    ZDATA%STATE_ = IBCLR(ZDATA%STATE_, ZDATA_FAILBIT)

  END SUBROUTINE ZDATA_CLEAR_FAIL

  SUBROUTINE ZDATA_CLOSE(ZDATA)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    INTEGER(KIND = C_INT) :: CODE

    ZDATA%OFFSET_ = 0
    ZDATA%SIZE_ = 0
    ZDATA%STATE_ = 0
    CODE = ZMQ_MSG_CLOSE(ZDATA%MESSAGE_)
    IF (CODE .LT. 0) ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_BADBIT)

  END SUBROUTINE ZDATA_CLOSE

  FUNCTION ZDATA_EOM(ZDATA) RESULT(FLAG)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(IN) :: ZDATA
    LOGICAL :: FLAG

    FLAG = BTEST(ZDATA%STATE_, ZDATA_EOMBIT)

  END FUNCTION ZDATA_EOM

  FUNCTION ZDATA_FAIL(ZDATA) RESULT(FLAG)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(IN) :: ZDATA
    LOGICAL :: FLAG

    FLAG = BTEST(ZDATA%STATE_, ZDATA_BADBIT) .OR. &
           BTEST(ZDATA%STATE_, ZDATA_FAILBIT)

  END FUNCTION ZDATA_FAIL

  FUNCTION ZDATA_GET_BOOL(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    LOGICAL :: VALUE

    INTEGER(KIND = C_INT) :: CODE

    CODE = ZDATA%GET_INT()
    IF (CODE .EQ. 0) THEN
      VALUE = .FALSE.
    ELSE
      VALUE = .TRUE.
    END IF

  END FUNCTION ZDATA_GET_BOOL

  FUNCTION ZDATA_GET_CHAR(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    CHARACTER(KIND = C_CHAR) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    VALUE = ' '
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        VALUE = TRANSFER(RANGE, VALUE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END FUNCTION ZDATA_GET_CHAR

  FUNCTION ZDATA_GET_C_STRING(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    CHARACTER(KIND = C_CHAR, LEN = :), ALLOCATABLE :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_INT) :: NBYTES
    INTEGER(KIND = C_SIZE_T) :: LAST
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    NBYTES = ZDATA%GET_INT()
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      IF (NBYTES .GT. 0) THEN
        LAST = ZDATA%OFFSET_ + NBYTES - 1
        IF (LAST .GT. ZDATA%SIZE_) THEN
          ZDATA%OFFSET_ = ZDATA%OFFSET_ - C_SIZEOF(NBYTES)
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
        ELSE
          ALLOCATE(CHARACTER(KIND = C_CHAR, LEN = NBYTES) :: VALUE)
          MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
          CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
          RANGE => BUFFER(ZDATA%OFFSET_:LAST)
          VALUE = TRANSFER(RANGE, VALUE)
          ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
          IF (LAST .EQ. ZDATA%SIZE_) THEN
            ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
          END IF
        END IF
      ELSE
        ZDATA%OFFSET_ = ZDATA%OFFSET_ - C_SIZEOF(NBYTES)
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      END IF
    END IF

  END FUNCTION ZDATA_GET_C_STRING

  FUNCTION ZDATA_GET_DOUBLE(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    REAL(KIND = C_DOUBLE) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    VALUE = 0._C_DOUBLE
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        VALUE = TRANSFER(RANGE, VALUE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END FUNCTION ZDATA_GET_DOUBLE

  FUNCTION ZDATA_GET_FLOAT(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    REAL(KIND = C_FLOAT) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    VALUE = 0._C_FLOAT
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        VALUE = TRANSFER(RANGE, VALUE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END FUNCTION ZDATA_GET_FLOAT

  FUNCTION ZDATA_GET_INT(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    INTEGER(KIND = C_INT) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    VALUE = 0_C_INT
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        VALUE = TRANSFER(RANGE, VALUE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END FUNCTION ZDATA_GET_INT

  FUNCTION ZDATA_GET_LONG(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    INTEGER(KIND = C_LONG) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    VALUE = 0_C_LONG
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        VALUE = TRANSFER(RANGE, VALUE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END FUNCTION ZDATA_GET_LONG

  FUNCTION ZDATA_GET_SHORT(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    INTEGER(KIND = C_SHORT) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    VALUE = 0_C_SHORT
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        VALUE = TRANSFER(RANGE, VALUE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END FUNCTION ZDATA_GET_SHORT

  FUNCTION ZDATA_GET_STRING(ZDATA) RESULT(VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    CHARACTER(KIND = C_CHAR, LEN = :), ALLOCATABLE :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_INT) :: NBYTES
    INTEGER(KIND = C_SIZE_T) :: LAST
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    NBYTES = ZDATA%GET_INT()
    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      IF (NBYTES .GT. 0) THEN
        LAST = ZDATA%OFFSET_ + NBYTES - 1
        IF (LAST .GT. ZDATA%SIZE_) THEN
          ZDATA%OFFSET_ = ZDATA%OFFSET_ - C_SIZEOF(NBYTES)
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
        ELSE
          ALLOCATE(CHARACTER(KIND = C_CHAR, LEN = NBYTES - 1) :: VALUE)
          MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
          CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
          RANGE => BUFFER(ZDATA%OFFSET_:LAST - 1)
          VALUE = TRANSFER(RANGE, VALUE)
          ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
          IF (LAST .EQ. ZDATA%SIZE_) THEN
            ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
          END IF
        END IF
      ELSE
        ZDATA%OFFSET_ = ZDATA%OFFSET_ - C_SIZEOF(NBYTES)
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      END IF
    END IF

  END FUNCTION ZDATA_GET_STRING

  FUNCTION ZDATA_GOOD(ZDATA) RESULT(FLAG)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(IN) :: ZDATA
    LOGICAL :: FLAG

    FLAG = (.NOT. BTEST(ZDATA%STATE_, ZDATA_BADBIT)) .AND. &
           (.NOT. BTEST(ZDATA%STATE_, ZDATA_EOMBIT)) .AND. &
           (.NOT. BTEST(ZDATA%STATE_, ZDATA_FAILBIT))

  END FUNCTION ZDATA_GOOD

  FUNCTION ZDATA_INIT() RESULT(ZDATA)

    IMPLICIT NONE
    TYPE(ZDATA_T) :: ZDATA

    INTEGER(KIND = C_INT) :: CODE

    IF (BTEST(ZDATA%STATE_, ZDATA_RECVBIT) .OR. &
        BTEST(ZDATA%STATE_, ZDATA_SENDBIT)) THEN
      CALL ZDATA%CLOSE()
    END IF

    ZDATA%OFFSET_ = 0
    ZDATA%SIZE_ = 0
    ZDATA%STATE_ = IBSET(0, ZDATA_RECVBIT)
    CODE = ZMQ_MSG_INIT(ZDATA%MESSAGE_)
    IF (CODE .LT. 0) ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_BADBIT)

  END FUNCTION ZDATA_INIT

  FUNCTION ZDATA_INIT_INT(SIZE) RESULT(ZDATA)

    IMPLICIT NONE
    INTEGER(KIND = C_INT), INTENT(IN) :: SIZE
    TYPE(ZDATA_T) :: ZDATA

    ZDATA = ZDATA_INIT_SIZE(INT(SIZE, C_SIZE_T))

  END FUNCTION ZDATA_INIT_INT

  FUNCTION ZDATA_INIT_SIZE(SIZE) RESULT(ZDATA)

    IMPLICIT NONE
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    TYPE(ZDATA_T) :: ZDATA

    INTEGER(KIND = C_INT) :: CODE

    IF (BTEST(ZDATA%STATE_, ZDATA_RECVBIT) .OR. &
        BTEST(ZDATA%STATE_, ZDATA_SENDBIT)) THEN
      CALL ZDATA%CLOSE()
    END IF

    ZDATA%OFFSET_ = 1
    ZDATA%STATE_ = IBSET(0, ZDATA_SENDBIT)
    CODE = ZMQ_MSG_INIT_SIZE(ZDATA%MESSAGE_, SIZE)
    ZDATA%SIZE_ = ZMQ_MSG_SIZE(ZDATA%MESSAGE_)
    IF (CODE .LT. 0) ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_BADBIT)

  END FUNCTION ZDATA_INIT_SIZE

  FUNCTION ZDATA_MSG(ZDATA) RESULT(MSG)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    TYPE(ZMQ_MSG_T) :: MSG

    MSG = ZDATA%MESSAGE_

  END FUNCTION ZDATA_MSG

  SUBROUTINE ZDATA_PUT_BOOL(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    LOGICAL, INTENT(IN) :: VALUE

    IF (VALUE) THEN
      CALL ZDATA%PUT_INT(1)
    ELSE
      CALL ZDATA%PUT_INT(0)
    END IF

  END SUBROUTINE ZDATA_PUT_BOOL

  SUBROUTINE ZDATA_PUT_CHAR(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    CHARACTER(KIND = C_CHAR), INTENT(IN) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        RANGE = TRANSFER(VALUE, RANGE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END SUBROUTINE ZDATA_PUT_CHAR

  SUBROUTINE ZDATA_PUT_C_STRING(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_INT) :: LENGTH
    INTEGER(KIND = C_SIZE_T) :: FIRST
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T) :: NBYTES
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LENGTH = INDEX(VALUE, C_NULL_CHAR)
      LAST = ZDATA%OFFSET_ + C_SIZEOF(LENGTH) + LENGTH - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        FIRST = ZDATA%OFFSET_
        LAST = FIRST + C_SIZEOF(LENGTH) - 1
        RANGE => BUFFER(FIRST:LAST)
        RANGE = TRANSFER(LENGTH, RANGE)
        FIRST = LAST + 1
        LAST = FIRST + LENGTH - 1
        RANGE => BUFFER(FIRST:LAST)
        RANGE = TRANSFER(VALUE, RANGE)
        ZDATA%OFFSET_ = LAST + 1
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END SUBROUTINE ZDATA_PUT_C_STRING

  SUBROUTINE ZDATA_PUT_DOUBLE(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    REAL(KIND = C_DOUBLE), INTENT(IN) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        RANGE = TRANSFER(VALUE, RANGE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END SUBROUTINE ZDATA_PUT_DOUBLE

  SUBROUTINE ZDATA_PUT_FLOAT(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    REAL(KIND = C_FLOAT), INTENT(IN) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        RANGE = TRANSFER(VALUE, RANGE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END SUBROUTINE ZDATA_PUT_FLOAT

  SUBROUTINE ZDATA_PUT_INT(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    INTEGER(KIND = C_INT), INTENT(IN) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        RANGE = TRANSFER(VALUE, RANGE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END SUBROUTINE ZDATA_PUT_INT

  SUBROUTINE ZDATA_PUT_LONG(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    INTEGER(KIND = C_LONG), INTENT(IN) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        RANGE = TRANSFER(VALUE, RANGE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END SUBROUTINE ZDATA_PUT_LONG

  SUBROUTINE ZDATA_PUT_SHORT(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    INTEGER(KIND = C_SHORT), INTENT(IN) :: VALUE

    TYPE(C_PTR) :: MESSAGE_DATA
    INTEGER(KIND = C_SIZE_T) :: LAST
    INTEGER(KIND = C_SIZE_T), PARAMETER :: NBYTES = C_SIZEOF(VALUE)
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: RANGE

    IF (.NOT. ZDATA%BAD() .AND. .NOT. ZDATA%EOM()) THEN
      LAST = ZDATA%OFFSET_ + NBYTES - 1
      IF (LAST .GT. ZDATA%SIZE_) THEN
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      ELSE
        MESSAGE_DATA = ZMQ_MSG_DATA(ZDATA%MESSAGE_)
        CALL C_F_POINTER(MESSAGE_DATA, BUFFER)
        RANGE => BUFFER(ZDATA%OFFSET_:LAST)
        RANGE = TRANSFER(VALUE, RANGE)
        ZDATA%OFFSET_ = ZDATA%OFFSET_ + NBYTES
        IF (LAST .EQ. ZDATA%SIZE_) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_EOMBIT)
        END IF
      END IF
    END IF

  END SUBROUTINE ZDATA_PUT_SHORT

  SUBROUTINE ZDATA_PUT_STRING(ZDATA, VALUE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: VALUE

    CALL ZDATA%PUT_C_STRING(VALUE // C_NULL_CHAR)

  END SUBROUTINE ZDATA_PUT_STRING

  FUNCTION ZDATA_RECV(ZDATA, SOCKET, FLAGS) RESULT(NBYTES)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    TYPE(C_PTR), VALUE, INTENT(IN) :: SOCKET
    INTEGER(KIND = C_INT), VALUE, INTENT(IN) :: FLAGS
    INTEGER(KIND = C_INT) :: NBYTES

    NBYTES = -1
    IF (.NOT. ZDATA%BAD()) THEN
      IF (BTEST(ZDATA%STATE_, ZDATA_RECVBIT)) THEN
        NBYTES = ZMQ_MSG_RECV(ZDATA%MESSAGE_, SOCKET, FLAGS)
        ZDATA%OFFSET_ = 1
        ZDATA%SIZE_ = ZMQ_MSG_SIZE(ZDATA%MESSAGE_)
        IF (NBYTES .LT. 0) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_BADBIT)
        END IF
      ELSE
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      END IF
    END IF

  END FUNCTION ZDATA_RECV

  FUNCTION ZDATA_SEND(ZDATA, SOCKET, FLAGS) RESULT(NBYTES)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA
    TYPE(C_PTR), VALUE, INTENT(IN) :: SOCKET
    INTEGER(KIND = C_INT), VALUE, INTENT(IN) :: FLAGS
    INTEGER(KIND = C_INT) :: NBYTES

    NBYTES = -1
    IF (.NOT. ZDATA%BAD()) THEN
      IF (BTEST(ZDATA%STATE_, ZDATA_SENDBIT)) THEN
        NBYTES = ZMQ_MSG_SEND(ZDATA%MESSAGE_, SOCKET, FLAGS)
        ZDATA%OFFSET_ = 0
        ZDATA%SIZE_ = 0
        ZDATA%STATE_ = 0
        IF (NBYTES .LT. 0) THEN
          ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_BADBIT)
        END IF
      ELSE
        ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_FAILBIT)
      END IF
    END IF

  END FUNCTION ZDATA_SEND

  FUNCTION ZDATA_SIZE(ZDATA) RESULT(SIZE)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(IN) :: ZDATA
    INTEGER(KIND = C_SIZE_T) :: SIZE

    SIZE = ZDATA%SIZE_

  END FUNCTION ZDATA_SIZE

  SUBROUTINE ZDATA_SWITCH_MODE(ZDATA)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(INOUT) :: ZDATA

    IF (BTEST(ZDATA%STATE_, ZDATA_RECVBIT)) THEN
      ZDATA%STATE_ = IBCLR(ZDATA%STATE_, ZDATA_RECVBIT)
      ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_SENDBIT)
      ZDATA%OFFSET_ = 1
    ELSE IF (BTEST(ZDATA%STATE_, ZDATA_SENDBIT)) THEN
      ZDATA%STATE_ = IBCLR(ZDATA%STATE_, ZDATA_SENDBIT)
      ZDATA%STATE_ = IBSET(ZDATA%STATE_, ZDATA_RECVBIT)
      ZDATA%OFFSET_ = 1
    END IF

  END SUBROUTINE ZDATA_SWITCH_MODE

  FUNCTION ZDATA_TELLP(ZDATA) RESULT(POSITION)

    IMPLICIT NONE
    CLASS(ZDATA_T), INTENT(IN) :: ZDATA
    INTEGER(KIND = C_SIZE_T) :: POSITION

    POSITION = ZDATA%OFFSET_

  END FUNCTION ZDATA_TELLP

END MODULE ZDATA
